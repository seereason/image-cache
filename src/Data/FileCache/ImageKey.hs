-- | An 'ImageKey' is a value that describes how to construct an image.

{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveLift #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeOperators #-}

module Data.FileCache.ImageKey
  ( -- * ImageKey
    ImageKey(..)
  , HasImageKey(imageKey)
  , OriginalKey(originalKey)
  , UprightKey(uprightKey)
  , EditedKey(editedKey)
  , ScaledKey(scaledKey)

  , ImagePath(ImagePath, _imagePathKey)
  , HasImagePath(imagePath)
  ) where

import Control.Monad ( ap )
import Data.Data ( Data )
import Data.FileCache.Rational ( showRational )
import Data.FileCache.File ( Checksum, File(_fileChksum) )
import Data.FileCache.ImageCrop ( Rotation(..), ImageCrop(..) )
import Data.FileCache.ImageType ( HasFileExtension(fileExtension), ImageType(..) )
import Data.FileCache.ImageSize ( HasImageSize(..), Units(..), Dimension(..), ImageSize(..) )
import Data.Monoid ( (<>) )
import Data.SafeCopy ( safeGet, safePut, SafeCopy(version) )
import Data.Serialize ( Serialize(..) )
import Data.Text ( pack, span, Text, unpack )
import Data.Typeable ( Typeable )
import GHC.Generics ( Generic )
-- import Language.Haskell.TH.Instances ()
import Language.Haskell.TH.Lift as TH ()
import Prelude hiding (span)
import Text.Parsec ( (<|>) )
import Text.PrettyPrint.HughesPJClass ( Pretty(pPrint), text )
import Web.Routes ( PathInfo(..), segment )
import Web.Routes.TH ( derivePathInfo )

-- * ImageKey

-- | Describes an ImageFile and, if it was derived from other image
-- files, how.
data ImageKey
    = ImageOriginal Checksum ImageType
    -- ^ An unmodified upload, the info lets us construct an URL
    | ImageCropped ImageCrop ImageKey
    -- ^ A cropped version of another image
    | ImageScaled ImageSize Rational ImageKey
    -- ^ A resized version of another image
    | ImageUpright ImageKey
    -- ^ Image uprighted using the EXIF orientation code, see  "Appraisal.Exif"
    deriving (Generic, Eq, Ord)

deriving instance Data ImageKey
deriving instance Read ImageKey
deriving instance Show ImageKey
deriving instance Typeable ImageKey
instance Serialize ImageKey where get = safeGet; put = safePut
-- This is not an extension of ImageKey_2, it is a new type
-- created by the migration of ImageCache.
instance SafeCopy ImageKey where version = 4

instance Pretty ImageKey where
    pPrint (ImageOriginal csum typ) = text (take 7 (unpack csum)) <> text (unpack (fileExtension typ))
    pPrint (ImageUpright x) = text "Upright (" <> pPrint x <> ")"
    pPrint (ImageCropped crop x) = text "Crop (" <> pPrint crop <> text ") (" <> pPrint x <> text ")"
    pPrint (ImageScaled sz dpi x) = text "Scale (" <> pPrint sz <> text " @" <> text (showRational dpi) <> text " dpi) (" <> pPrint x <> text ")"

class HasImageKey a where
  imageKey :: a -> ImageKey
instance HasImageKey ImageKey where
  imageKey = id

instance OriginalKey ImageKey where
  originalKey key@(ImageOriginal _ _) = key
  originalKey (ImageUpright key) = originalKey key
  originalKey (ImageScaled _ _ key) = originalKey key
  originalKey (ImageCropped _ key) = originalKey key

-- | Various ways to build an OriginalKey.
class OriginalKey a where
  originalKey :: a -> ImageKey
instance OriginalKey (Checksum, ImageType) where -- danger - Checksum is just String
  originalKey = uncurry ImageOriginal
--instance OriginalKey ImageFile where
--  originalKey (ImageFileReady i) = originalKey i
--  originalKey (ImageFileShape i) = originalKey i
instance OriginalKey (File, ImageType) where
  originalKey (f, typ) = ImageOriginal (_fileChksum f) typ

class UprightKey a where
  uprightKey :: a -> ImageKey
instance UprightKey ImageKey where
  uprightKey (ImageScaled _ _ key) = uprightKey key
  uprightKey (ImageCropped _ key) = uprightKey key
  uprightKey (ImageUpright key) = uprightKey key
  uprightKey key@(ImageOriginal _ _) = ImageUpright key

class EditedKey a where
  editedKey :: a -> ImageKey
instance EditedKey ImageKey where
  editedKey (ImageScaled _ _ key) = editedKey key
  editedKey key@(ImageCropped _ _) = key
  editedKey key@(ImageUpright _) = key
  editedKey key@(ImageOriginal _ _) = ImageUpright key

-- | Compute an image key that has a certain size at the given dpi
class HasImageSize size => ScaledKey size a where
  scaledKey :: size -> Rational -> a -> ImageKey
instance ScaledKey ImageSize ImageKey where
  scaledKey size dpi x = ImageScaled size dpi (editedKey x)

-- | In order to build an image's path or url we need the ImageKey,
-- which tells us how the image is transformed, and we need the
-- Imagetype so we can append the correct file extension.  We could
-- also get it from the File record in ImageReady, but that isn't
-- available until the image has been fully generated by the server.
newtype ImagePath =
  ImagePath { _imagePathKey :: ImageKey
            -- , _imagePathType :: ImageType
            } deriving (Generic, Eq, Ord)

class HasImagePath a where imagePath :: a -> ImagePath
instance HasImagePath ImagePath where imagePath = id
instance HasImageKey ImagePath where imageKey (ImagePath x) = imageKey x

-- | Modified PathInfo instance that omits the "image-original" tag,
-- if none of the other tags appear it is assumed.  This matches the
-- structure of the image cache.
instance PathInfo ImageKey where
  toPathSegments inp =
    case inp of
      ImageCropped arg_a9peM arg_a9peN -> [pack "image-cropped"] <> toPathSegments arg_a9peM <> toPathSegments arg_a9peN
      ImageScaled arg_a9peO arg_a9peP arg_a9peQ -> [pack "image-scaled"] <> toPathSegments arg_a9peO <> toPathSegments arg_a9peP <> toPathSegments arg_a9peQ
      ImageUpright arg_a9peR -> [pack "image-upright"] <> toPathSegments arg_a9peR
      ImageOriginal csum ityp -> {-[pack "image-original"] <>-} [csum <> fileExtension ityp]
  fromPathSegments =
    ap (ap (segment (pack "image-cropped") >> return ImageCropped) fromPathSegments) fromPathSegments <|>
    ap (ap (ap (segment (pack "image-scaled") >> return ImageScaled) fromPathSegments) fromPathSegments) fromPathSegments <|>
    ap (segment (pack "image-upright") >> return ImageUpright) fromPathSegments <|>
    (parseOriginal <$> fromPathSegments)
    -- ap (ap ({-segment (pack "image-original") >>-} return ImageOriginal) fromPathSegments) fromPathSegments
    where
      parseOriginal :: Text -> ImageKey
      parseOriginal t = let (name, ext) = span (/= '.') t in
                          ImageOriginal name (case ext of
                                                 ".jpg" -> JPEG
                                                 ".ppm" -> PPM
                                                 ".png" -> PNG
                                                 ".gif" -> GIF
                                                 ".pdf" -> PDF
                                                 _ -> Unknown)

{-
λ> toPathInfo (ImageOriginal "1c478f102062f2e0fd4b8147fb3bbfd0" JPEG)
"/image-original/1c478f102062f2e0fd4b8147fb3bbfd0"
λ> toPathInfo (ImageUpright (ImageOriginal "1c478f102062f2e0fd4b8147fb3bbfd0" JPEG))
"/image-upright/image-original/1c478f102062f2e0fd4b8147fb3bbfd0"
λ> toPathInfo (ImageScaled (ImageSize TheWidth 3 Inches) (1 % 3) (ImageOriginal "1c478f102062f2e0fd4b8147fb3bbfd0" JPEG))
"/image-scaled/image-size/the-width/3/1/inches/1/3/image-original/1c478f102062f2e0fd4b8147fb3bbfd0"
-}

#if 0
-- Ultimately we will need a custom PathInfo instance

pChecksum :: String.Parser Checksum
pChecksum = pack <$> many (noneOf ['.'])

pExtension :: String.Parser ImageType
pExtension = testExtension <$> many anyChar
  where
    testExtension :: String -> ImageType
    testExtension ".jpg" = JPEG
    testExtension ".png" = PNG
    testExtension ".pbm" = PPM
    testExtension ".pgm" = PPM
    testExtension ".ppm" = PPM
    testExtension ".pnm" = PPM
    testExtension ".gif" = GIF
    testExtension s = error ("testExtension " <> show s)

pImageKey :: String.Parser ImageKey
pImageKey = ImageOriginal <$> pChecksum <*> pExtension

instance HasImageType ImageKey => PathInfo ImageKey where
  toPathSegments (ImageOriginal csum typ) = [csum <> fileExtension typ]
  fromPathSegments = p2u pImageKey
#endif

#if MIN_VERSION_template_haskell(2,17,0)
instance PathInfo ImagePath where
      toPathSegments inp_aAxt
        = case inp_aAxt of {
            ImagePath arg_aAxu
              -> ((++) [pack "image-path"]) (toPathSegments arg_aAxu) }
      fromPathSegments
        = (ap (segment (pack "image-path") >> return ImagePath))
            fromPathSegments
instance PathInfo ImageCrop where
      toPathSegments inp_aAxw
        = case inp_aAxw of {
            ImageCrop arg_aAxx arg_aAxy arg_aAxz arg_aAxA arg_aAxB
              -> ((++) [pack "image-crop"])
                   (((++) (toPathSegments arg_aAxx))
                      (((++) (toPathSegments arg_aAxy))
                         (((++) (toPathSegments arg_aAxz))
                            (((++) (toPathSegments arg_aAxA)) (toPathSegments arg_aAxB))))) }
      fromPathSegments
        = (ap
             ((ap
                 ((ap
                     ((ap
                         ((ap
                             (segment (pack "image-crop")
                                >> return ImageCrop))
                            fromPathSegments))
                        fromPathSegments))
                    fromPathSegments))
                fromPathSegments))
            fromPathSegments
instance PathInfo ImageSize where
      toPathSegments inp_aAxV
        = case inp_aAxV of {
            ImageSize arg_aAxW arg_aAxX arg_aAxY
              -> ((++) [pack "image-size"])
                   (((++) (toPathSegments arg_aAxW))
                      (((++) (toPathSegments arg_aAxX)) (toPathSegments arg_aAxY))) }
      fromPathSegments
        = (ap
             ((ap
                 ((ap
                     (segment (pack "image-size")
                        >> return ImageSize))
                    fromPathSegments))
                fromPathSegments))
            fromPathSegments
instance PathInfo Dimension where
      toPathSegments inp_aAy2
        = case inp_aAy2 of
            TheHeight -> [pack "the-height"]
            TheWidth -> [pack "the-width"]
            TheArea -> [pack "the-area"]
      fromPathSegments
        = ((<|>)
             (((<|>)
                 (segment (pack "the-height")
                    >> return TheHeight))
                (segment (pack "the-width")
                   >> return TheWidth)))
            (segment (pack "the-area")
               >> return TheArea)
instance PathInfo Units where
      toPathSegments inp_aAy6
        = case inp_aAy6 of
            Inches -> [pack "inches"]
            Cm -> [pack "cm"]
            Points -> [pack "points"]
      fromPathSegments
        = ((<|>)
             (((<|>)
                 (segment (pack "inches")
                    >> return Inches))
                (segment (pack "cm") >> return Cm)))
            (segment (pack "points") >> return Points)
instance PathInfo Rotation where
      toPathSegments inp_aAyb
        = case inp_aAyb of
            ZeroHr -> [pack "zero-hr"]
            ThreeHr -> [pack "three-hr"]
            SixHr -> [pack "six-hr"]
            NineHr -> [pack "nine-hr"]
      fromPathSegments
        = ((<|>)
             (((<|>)
                 (((<|>)
                     (segment (pack "zero-hr")
                        >> return ZeroHr))
                    (segment (pack "three-hr")
                       >> return ThreeHr)))
                (segment (pack "six-hr")
                   >> return SixHr)))
            (segment (pack "nine-hr")
               >> return NineHr)
#else
$(concat <$>
  sequence
  [ derivePathInfo ''ImagePath
  , derivePathInfo ''ImageCrop
  , derivePathInfo ''ImageSize
  , derivePathInfo ''Dimension
  , derivePathInfo ''Units
  , derivePathInfo ''Rotation
  ])
#endif
